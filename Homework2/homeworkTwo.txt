 1 уровень сложности: Level 1

​​Какова временная сложность?

	void test1(int n)
	{
   		if (n==1)
      			return;
   		for (int i=1; i<=n; i++)
       			for (int j=1; j<=n; j++)
           			System.out.println("*");
           			break;
	}

Answer: у алгоритма будет квадратичная сложность O(n^2).Заходит в один цикл, берет один элемент, и в каждом из этих элементов делает проход по всем элементам вложенного цикла.



	void test2(int n)
	{
   		int a = 0;
	for (i = 0; i < n; i++)
   		for (j = n; j > i; j--)
       			a = a + i + j;
	}

Answer: у алгоритма будет квадратичная сложность O(n^2). Но тут итераций во внешнем цикле будет n, а во внутреннем он уже не пройдет столько же шагов, а только часть, пока j не сравняется c i, а это (n-i). например:
n = 5;
i = 0 :=> j идет от 5 до 0 (5,4,3,2,1)
i = 1 :=> j идет от 5 до 1, не включаяя ее (5,4,3,2)
i = 2 :=> j идет от 5 до 2, не включаяя ее (5,4,3)
i = 3 :=> j идет от 5 до 3, не включаяя ее (5,4)
i = 4 :=> j идет от 5 до 4, не включаяя его (5)

Сумма арифметической прогрессии: n*(aInit + aLast)/2 - это определит число наших шагов, т.е. n*(n +1)/2. 
Значит, О((n^2+n)/2) 
Убираем константу 2, убираем неважную сложность n, и получаем О(n^2)


Level 2
​​Какова временная сложность?
	void test3(int n)
	{
   		int i, j, a = 0;
		for (i = n/2; i <=n; i++)
   			for (j = 2; j <=n; j=j*2)
       				a=a+n/2;   
	}



Answer: Во внешнем цикле имеем ((n+2)/2) шагов, во внутреннем log2(n)

n = 1;
i = 5 :=> j идет от 2 до n с шагом j*2 (2, 4, 8)
i = 6 :=> j идет от 2 до n с шагом j*2 (2, 4, 8)
i = 7 :=> j идет от 2 до n с шагом j*2 (2, 4, 8)
i = 8 :=> j идет от 2 до n с шагом j*2 (2, 4, 8)
i = 9 :=> j идет от 2 до n с шагом j*2 (2, 4, 8)
i = 10 :=> j идет от 2 до n с шагом j*2 (2, 4, 8)

Вложенный цикл имеет логарифмическую зависимость. Скажем log2(n).
При n = 10, 2 можно возвести в 3 степень = 8 (3 шага)
при n = 20, 2 можно возвести в 4 степень = 16 (4 шага)
при n = 50, 2 можно возвести в 5 степень = 32 (5 шагов)

После упрощения: O(n*log2(n)) = O(n*log(n)), если отбросим константную основу логарифма. log(n) нельзя убрать, потому как он не прибавляется, и в данном случае оказывает существенное влияние на результат.



	*void test4(int n)
	{
   		int a = 0, i = n;
		while (i > 0) {
   			a += i;
   			i /= 2;
		}
	}
Answer: O(log(n)) - насколько я понимаю, такова будет временная сложность. 
Например:
i = 20, и шаг будет меняться:
i = 20, 10, 5, 2.5, 1.25, 0.625, 0.3125, ... И так цикл будет плавно подходить к 0, но на самом деле так до него и не дойдет.